module.exports = {

"[project]/node_modules/next/dist/compiled/@next/font/dist/constants.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.allowedDisplayValues = void 0;
exports.allowedDisplayValues = [
    'auto',
    'block',
    'swap',
    'fallback',
    'optional'
];
}}),
"[project]/node_modules/next/dist/compiled/@next/font/dist/format-available-values.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatAvailableValues = void 0;
/**
 * Formats an array of values into a string that can be used error messages.
 * ["a", "b", "c"] => "`a`, `b`, `c`"
 */ const formatAvailableValues = (values)=>values.map((val)=>`\`${val}\``).join(', ');
exports.formatAvailableValues = formatAvailableValues;
}}),
"[project]/node_modules/next/dist/compiled/@next/font/dist/next-font-error.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nextFontError = nextFontError;
/**
 * Throw NextFontError error. Used by the WellKnownErrorsPlugin to format errors thrown by next/font.
 */ function nextFontError(message) {
    const err = new Error(message);
    err.name = 'NextFontError';
    throw err;
}
}}),
"[project]/node_modules/next/dist/compiled/@next/font/dist/local/pick-font-file-for-fallback-generation.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pickFontFileForFallbackGeneration = pickFontFileForFallbackGeneration;
const next_font_error_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/next-font-error.js [app-rsc] (ecmascript)");
const NORMAL_WEIGHT = 400;
const BOLD_WEIGHT = 700;
/**
 * Convert the weight string to a number so it can be used for comparison.
 * Weights can be defined as a number, 'normal' or 'bold'. https://developer.mozilla.org/docs/Web/CSS/@font-face/font-weight
 */ function getWeightNumber(weight) {
    return weight === 'normal' ? NORMAL_WEIGHT : weight === 'bold' ? BOLD_WEIGHT : Number(weight);
}
/**
 * Get the distance from normal (400) weight for the provided weight.
 * If it's not a variable font we can just return the distance.
 * If it's a variable font we need to compare its weight range to 400.
 */ function getDistanceFromNormalWeight(weight) {
    if (!weight) return 0;
    // If it's a variable font the weight is defined with two numbers "100 900", rather than just one "400"
    const [firstWeight, secondWeight] = weight.trim().split(/ +/).map(getWeightNumber);
    if (Number.isNaN(firstWeight) || Number.isNaN(secondWeight)) {
        (0, next_font_error_1.nextFontError)(`Invalid weight value in src array: \`${weight}\`.\nExpected \`normal\`, \`bold\` or a number.`);
    }
    // If the weight doesn't have have a second value, it's not a variable font
    // If that's the case, just return the distance from normal weight
    if (!secondWeight) {
        return firstWeight - NORMAL_WEIGHT;
    }
    // Normal weight is within variable font range
    if (firstWeight <= NORMAL_WEIGHT && secondWeight >= NORMAL_WEIGHT) {
        return 0;
    }
    // Normal weight is outside variable font range
    // Return the distance of normal weight to the variable font range
    const firstWeightDistance = firstWeight - NORMAL_WEIGHT;
    const secondWeightDistance = secondWeight - NORMAL_WEIGHT;
    if (Math.abs(firstWeightDistance) < Math.abs(secondWeightDistance)) {
        return firstWeightDistance;
    }
    return secondWeightDistance;
}
/**
 * If multiple font files are provided for a font family, we need to pick one to use for the automatic fallback generation.
 * This function returns the font file that is most likely to be used for the bulk of the text on a page.
 *
 * There are some assumptions here about the text on a page when picking the font file:
 * - Most of the text will have normal weight, use the one closest to 400
 * - Most of the text will have normal style, prefer normal over italic
 * - If two font files have the same distance from normal weight, the thinner one will most likely be the bulk of the text
 */ function pickFontFileForFallbackGeneration(fontFiles) {
    return fontFiles.reduce((usedFontFile, currentFontFile)=>{
        if (!usedFontFile) return currentFontFile;
        const usedFontDistance = getDistanceFromNormalWeight(usedFontFile.weight);
        const currentFontDistance = getDistanceFromNormalWeight(currentFontFile.weight);
        // Prefer normal style if they have the same weight
        if (usedFontDistance === currentFontDistance && (typeof currentFontFile.style === 'undefined' || currentFontFile.style === 'normal')) {
            return currentFontFile;
        }
        const absUsedDistance = Math.abs(usedFontDistance);
        const absCurrentDistance = Math.abs(currentFontDistance);
        // Use closest absolute distance to normal weight
        if (absCurrentDistance < absUsedDistance) return currentFontFile;
        // Prefer the thinner font if both have the same absolute distance from normal weight
        if (absUsedDistance === absCurrentDistance && currentFontDistance < usedFontDistance) {
            return currentFontFile;
        }
        return usedFontFile;
    });
}
}}),
"[project]/node_modules/next/dist/compiled/@next/font/dist/local/get-fallback-metrics-from-font-file.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getFallbackMetricsFromFontFile = getFallbackMetricsFromFontFile;
// The font metadata of the fallback fonts, retrieved with fontkit on system font files
// The average width is calculated with the calcAverageWidth function below
const DEFAULT_SANS_SERIF_FONT = {
    name: 'Arial',
    azAvgWidth: 934.5116279069767,
    unitsPerEm: 2048
};
const DEFAULT_SERIF_FONT = {
    name: 'Times New Roman',
    azAvgWidth: 854.3953488372093,
    unitsPerEm: 2048
};
/**
 * Calculate the average character width of a font file.
 * Used to calculate the size-adjust property by comparing the fallback average with the loaded font average.
 */ function calcAverageWidth(font) {
    try {
        /**
         * Finding the right characters to use when calculating the average width is tricky.
         * We can't just use the average width of all characters, because we have to take letter frequency into account.
         * We also have to take word length into account, because the font's space width usually differ a lot from other characters.
         * The goal is to find a string that'll give you a good average width, given most texts in most languages.
         *
         * TODO: Currently only works for the latin alphabet. Support more languages by finding the right characters for additional languages.
         *
         * The used characters were decided through trial and error with letter frequency and word length tables as a guideline.
         * E.g. https://en.wikipedia.org/wiki/Letter_frequency
         */ const avgCharacters = 'aaabcdeeeefghiijklmnnoopqrrssttuvwxyz      ';
        // Check if the font file has all the characters we need to calculate the average width
        const hasAllChars = font.glyphsForString(avgCharacters).flatMap((glyph)=>glyph.codePoints).every((codePoint)=>font.hasGlyphForCodePoint(codePoint));
        if (!hasAllChars) return undefined;
        const widths = font.glyphsForString(avgCharacters).map((glyph)=>glyph.advanceWidth);
        const totalWidth = widths.reduce((sum, width)=>sum + width, 0);
        return totalWidth / widths.length;
    } catch  {
        // Could not calculate average width from the font file, skip size-adjust
        return undefined;
    }
}
function formatOverrideValue(val) {
    return Math.abs(val * 100).toFixed(2) + '%';
}
/**
 * Given a font file and category, calculate the fallback font override values.
 * The returned values can be used to generate a CSS @font-face declaration.
 *
 * For example:
 * @font-face {
 *   font-family: local-font;
 *   src: local(Arial);
 *   size-adjust: 90%;
 * }
 *
 * Read more about this technique in these texts by the Google Aurora team:
 * https://developer.chrome.com/blog/font-fallbacks/
 * https://docs.google.com/document/d/e/2PACX-1vRsazeNirATC7lIj2aErSHpK26hZ6dA9GsQ069GEbq5fyzXEhXbvByoftSfhG82aJXmrQ_sJCPBqcx_/pub
 */ function getFallbackMetricsFromFontFile(font, category = 'serif') {
    const fallbackFont = category === 'serif' ? DEFAULT_SERIF_FONT : DEFAULT_SANS_SERIF_FONT;
    const azAvgWidth = calcAverageWidth(font);
    const { ascent, descent, lineGap, unitsPerEm } = font;
    const fallbackFontAvgWidth = fallbackFont.azAvgWidth / fallbackFont.unitsPerEm;
    let sizeAdjust = azAvgWidth ? azAvgWidth / unitsPerEm / fallbackFontAvgWidth : 1;
    return {
        ascentOverride: formatOverrideValue(ascent / (unitsPerEm * sizeAdjust)),
        descentOverride: formatOverrideValue(descent / (unitsPerEm * sizeAdjust)),
        lineGapOverride: formatOverrideValue(lineGap / (unitsPerEm * sizeAdjust)),
        fallbackFont: fallbackFont.name,
        sizeAdjust: formatOverrideValue(sizeAdjust)
    };
}
}}),
"[project]/node_modules/next/dist/compiled/@next/font/dist/local/validate-local-font-function-call.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateLocalFontFunctionCall = validateLocalFontFunctionCall;
const constants_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/constants.js [app-rsc] (ecmascript)");
const format_available_values_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/format-available-values.js [app-rsc] (ecmascript)");
const next_font_error_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/next-font-error.js [app-rsc] (ecmascript)");
const extToFormat = {
    woff: 'woff',
    woff2: 'woff2',
    ttf: 'truetype',
    otf: 'opentype',
    eot: 'embedded-opentype'
};
/**
 * Validate the data recieved from next-swc next-transform-font on next/font/local calls
 */ function validateLocalFontFunctionCall(functionName, fontData) {
    if (functionName) {
        (0, next_font_error_1.nextFontError)(`next/font/local has no named exports`);
    }
    let { src, display = 'swap', weight, style, fallback, preload = true, variable, adjustFontFallback, declarations } = fontData || {};
    if (!constants_1.allowedDisplayValues.includes(display)) {
        (0, next_font_error_1.nextFontError)(`Invalid display value \`${display}\`.\nAvailable display values: ${(0, format_available_values_1.formatAvailableValues)(constants_1.allowedDisplayValues)}`);
    }
    if (!src) {
        (0, next_font_error_1.nextFontError)('Missing required `src` property');
    }
    if (!Array.isArray(src)) {
        src = [
            {
                path: src,
                weight,
                style
            }
        ];
    } else {
        if (src.length === 0) {
            (0, next_font_error_1.nextFontError)('Unexpected empty `src` array.');
        }
    }
    src = src.map((fontFile)=>{
        var _a;
        const ext = (_a = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFile.path)) === null || _a === void 0 ? void 0 : _a[1];
        if (!ext) {
            (0, next_font_error_1.nextFontError)(`Unexpected file \`${fontFile.path}\``);
        }
        return {
            ...fontFile,
            ext,
            format: extToFormat[ext]
        };
    });
    if (Array.isArray(declarations)) {
        declarations.forEach((declaration)=>{
            if ([
                'font-family',
                'src',
                'font-display',
                'font-weight',
                'font-style'
            ].includes(declaration === null || declaration === void 0 ? void 0 : declaration.prop)) {
                (0, next_font_error_1.nextFontError)(`Invalid declaration prop: \`${declaration.prop}\``);
            }
        });
    }
    return {
        src,
        display,
        weight,
        style,
        fallback,
        preload,
        variable,
        adjustFontFallback,
        declarations
    };
}
}}),
"[project]/node_modules/next/dist/compiled/@next/font/dist/local/loader.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
// @ts-ignore
// eslint-disable-next-line import/no-extraneous-dependencies
let fontFromBuffer;
try {
    const mod = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/fontkit/index.js [app-rsc] (ecmascript)").default;
    fontFromBuffer = mod.default || mod;
} catch  {}
const util_1 = __turbopack_require__("[externals]/util [external] (util, cjs)");
const pick_font_file_for_fallback_generation_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/local/pick-font-file-for-fallback-generation.js [app-rsc] (ecmascript)");
const get_fallback_metrics_from_font_file_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/local/get-fallback-metrics-from-font-file.js [app-rsc] (ecmascript)");
const validate_local_font_function_call_1 = __turbopack_require__("[project]/node_modules/next/dist/compiled/@next/font/dist/local/validate-local-font-function-call.js [app-rsc] (ecmascript)");
const nextFontLocalFontLoader = async ({ functionName, variableName, data, emitFontFile, resolve, loaderContext })=>{
    const { src, display, fallback, preload, variable, adjustFontFallback, declarations, weight: defaultWeight, style: defaultStyle } = (0, validate_local_font_function_call_1.validateLocalFontFunctionCall)(functionName, data[0]);
    // Load all font files and emit them to the .next output directory
    // Also generate a @font-face CSS for each font file
    const fontFiles = await Promise.all(src.map(async ({ path, style, weight, ext, format })=>{
        const resolved = await resolve(path);
        const fileBuffer = await (0, util_1.promisify)(loaderContext.fs.readFile)(resolved);
        const fontUrl = emitFontFile(fileBuffer, ext, preload, typeof adjustFontFallback === 'undefined' || !!adjustFontFallback);
        // Try to load font metadata from the font file using fontkit.
        // The data is used to calculate the fallback font override values.
        let fontMetadata;
        try {
            fontMetadata = fontFromBuffer === null || fontFromBuffer === void 0 ? void 0 : fontFromBuffer(fileBuffer);
        } catch (e) {
            console.error(`Failed to load font file: ${resolved}\n${e}`);
        }
        // Get all values that should be added to the @font-face declaration
        const fontFaceProperties = [
            ...declarations ? declarations.map(({ prop, value })=>[
                    prop,
                    value
                ]) : [],
            [
                'font-family',
                variableName
            ],
            [
                'src',
                `url(${fontUrl}) format('${format}')`
            ],
            [
                'font-display',
                display
            ],
            ...(weight !== null && weight !== void 0 ? weight : defaultWeight) ? [
                [
                    'font-weight',
                    weight !== null && weight !== void 0 ? weight : defaultWeight
                ]
            ] : [],
            ...(style !== null && style !== void 0 ? style : defaultStyle) ? [
                [
                    'font-style',
                    style !== null && style !== void 0 ? style : defaultStyle
                ]
            ] : []
        ];
        // Generate the @font-face CSS from the font-face properties
        const css = `@font-face {\n${fontFaceProperties.map(([property, value])=>`${property}: ${value};`).join('\n')}\n}\n`;
        return {
            css,
            fontMetadata,
            weight,
            style
        };
    }));
    // Calculate the fallback font override values using the font file metadata
    let adjustFontFallbackMetrics;
    if (adjustFontFallback !== false) {
        const fallbackFontFile = (0, pick_font_file_for_fallback_generation_1.pickFontFileForFallbackGeneration)(fontFiles);
        if (fallbackFontFile.fontMetadata) {
            adjustFontFallbackMetrics = (0, get_fallback_metrics_from_font_file_1.getFallbackMetricsFromFontFile)(fallbackFontFile.fontMetadata, adjustFontFallback === 'Times New Roman' ? 'serif' : 'sans-serif');
        }
    }
    return {
        css: fontFiles.map(({ css })=>css).join('\n'),
        fallbackFonts: fallback,
        weight: src.length === 1 ? src[0].weight : undefined,
        style: src.length === 1 ? src[0].style : undefined,
        variable,
        adjustFontFallback: adjustFontFallbackMetrics
    };
};
exports.default = nextFontLocalFontLoader;
}}),

};

//# sourceMappingURL=node_modules_next_dist_compiled_%40next_font_dist_815945._.js.map