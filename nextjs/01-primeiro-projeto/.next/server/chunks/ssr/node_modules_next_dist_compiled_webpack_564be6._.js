module.exports = {

"[project]/node_modules/next/dist/compiled/webpack/HotModuleReplacement.runtime.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// @ts-nocheck
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
var $interceptModuleExecution$ = undefined;
var $moduleCache$ = undefined;
// eslint-disable-next-line no-unused-vars
var $hmrModuleData$ = undefined;
/** @type {() => Promise}  */ var $hmrDownloadManifest$ = undefined;
var $hmrDownloadUpdateHandlers$ = undefined;
var $hmrInvalidateModuleHandlers$ = undefined;
var __webpack_require__ = undefined;
module.exports = function() {
    var currentModuleData = {};
    var installedModules = $moduleCache$;
    // module and require creation
    var currentChildModule;
    var currentParents = [];
    // status
    var registeredStatusHandlers = [];
    var currentStatus = "idle";
    // while downloading
    var blockingPromises = 0;
    var blockingPromisesWaiting = [];
    // The update info
    var currentUpdateApplyHandlers;
    var queuedInvalidatedModules;
    $hmrModuleData$ = currentModuleData;
    $interceptModuleExecution$.push(function(options) {
        var module1 = options.module;
        var require = createRequire(options.require, options.id);
        module1.hot = createModuleHotObject(options.id, module1);
        module1.parents = currentParents;
        module1.children = [];
        currentParents = [];
        options.require = require;
    });
    $hmrDownloadUpdateHandlers$ = {};
    $hmrInvalidateModuleHandlers$ = {};
    function createRequire(require, moduleId) {
        var me = installedModules[moduleId];
        if (!me) return require;
        var fn = function(request) {
            if (me.hot.active) {
                if (installedModules[request]) {
                    var parents = installedModules[request].parents;
                    if (parents.indexOf(moduleId) === -1) {
                        parents.push(moduleId);
                    }
                } else {
                    currentParents = [
                        moduleId
                    ];
                    currentChildModule = request;
                }
                if (me.children.indexOf(request) === -1) {
                    me.children.push(request);
                }
            } else {
                console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
                currentParents = [];
            }
            return require(request);
        };
        var createPropertyDescriptor = function(name) {
            return {
                configurable: true,
                enumerable: true,
                get: function() {
                    return require[name];
                },
                set: function(value) {
                    require[name] = value;
                }
            };
        };
        for(var name in require){
            if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
                Object.defineProperty(fn, name, createPropertyDescriptor(name));
            }
        }
        fn.e = function(chunkId, fetchPriority) {
            return trackBlockingPromise(require.e(chunkId, fetchPriority));
        };
        return fn;
    }
    function createModuleHotObject(moduleId, me) {
        var _main = currentChildModule !== moduleId;
        var hot = {
            // private stuff
            _acceptedDependencies: {},
            _acceptedErrorHandlers: {},
            _declinedDependencies: {},
            _selfAccepted: false,
            _selfDeclined: false,
            _selfInvalidated: false,
            _disposeHandlers: [],
            _main: _main,
            _requireSelf: function() {
                currentParents = me.parents.slice();
                currentChildModule = _main ? undefined : moduleId;
                __webpack_require__(moduleId);
            },
            // Module API
            active: true,
            accept: function(dep, callback, errorHandler) {
                if (dep === undefined) hot._selfAccepted = true;
                else if (typeof dep === "function") hot._selfAccepted = dep;
                else if (typeof dep === "object" && dep !== null) {
                    for(var i = 0; i < dep.length; i++){
                        hot._acceptedDependencies[dep[i]] = callback || function() {};
                        hot._acceptedErrorHandlers[dep[i]] = errorHandler;
                    }
                } else {
                    hot._acceptedDependencies[dep] = callback || function() {};
                    hot._acceptedErrorHandlers[dep] = errorHandler;
                }
            },
            decline: function(dep) {
                if (dep === undefined) hot._selfDeclined = true;
                else if (typeof dep === "object" && dep !== null) for(var i = 0; i < dep.length; i++)hot._declinedDependencies[dep[i]] = true;
                else hot._declinedDependencies[dep] = true;
            },
            dispose: function(callback) {
                hot._disposeHandlers.push(callback);
            },
            addDisposeHandler: function(callback) {
                hot._disposeHandlers.push(callback);
            },
            removeDisposeHandler: function(callback) {
                var idx = hot._disposeHandlers.indexOf(callback);
                if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
            },
            invalidate: function() {
                this._selfInvalidated = true;
                switch(currentStatus){
                    case "idle":
                        currentUpdateApplyHandlers = [];
                        Object.keys($hmrInvalidateModuleHandlers$).forEach(function(key) {
                            $hmrInvalidateModuleHandlers$[key](moduleId, currentUpdateApplyHandlers);
                        });
                        setStatus("ready");
                        break;
                    case "ready":
                        Object.keys($hmrInvalidateModuleHandlers$).forEach(function(key) {
                            $hmrInvalidateModuleHandlers$[key](moduleId, currentUpdateApplyHandlers);
                        });
                        break;
                    case "prepare":
                    case "check":
                    case "dispose":
                    case "apply":
                        (queuedInvalidatedModules = queuedInvalidatedModules || []).push(moduleId);
                        break;
                    default:
                        break;
                }
            },
            // Management API
            check: hotCheck,
            apply: hotApply,
            status: function(l) {
                if (!l) return currentStatus;
                registeredStatusHandlers.push(l);
            },
            addStatusHandler: function(l) {
                registeredStatusHandlers.push(l);
            },
            removeStatusHandler: function(l) {
                var idx = registeredStatusHandlers.indexOf(l);
                if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
            },
            // inherit from previous dispose call
            data: currentModuleData[moduleId]
        };
        currentChildModule = undefined;
        return hot;
    }
    function setStatus(newStatus) {
        currentStatus = newStatus;
        var results = [];
        for(var i = 0; i < registeredStatusHandlers.length; i++)results[i] = registeredStatusHandlers[i].call(null, newStatus);
        return Promise.all(results).then(function() {});
    }
    function unblock() {
        if (--blockingPromises === 0) {
            setStatus("ready").then(function() {
                if (blockingPromises === 0) {
                    var list = blockingPromisesWaiting;
                    blockingPromisesWaiting = [];
                    for(var i = 0; i < list.length; i++){
                        list[i]();
                    }
                }
            });
        }
    }
    function trackBlockingPromise(promise) {
        switch(currentStatus){
            case "ready":
                setStatus("prepare");
            /* fallthrough */ case "prepare":
                blockingPromises++;
                promise.then(unblock, unblock);
                return promise;
            default:
                return promise;
        }
    }
    function waitForBlockingPromises(fn) {
        if (blockingPromises === 0) return fn();
        return new Promise(function(resolve) {
            blockingPromisesWaiting.push(function() {
                resolve(fn());
            });
        });
    }
    function hotCheck(applyOnUpdate) {
        if (currentStatus !== "idle") {
            throw new Error("check() is only allowed in idle status");
        }
        return setStatus("check").then($hmrDownloadManifest$).then(function(update) {
            if (!update) {
                return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(function() {
                    return null;
                });
            }
            return setStatus("prepare").then(function() {
                var updatedModules = [];
                currentUpdateApplyHandlers = [];
                return Promise.all(Object.keys($hmrDownloadUpdateHandlers$).reduce(function(promises, key) {
                    $hmrDownloadUpdateHandlers$[key](update.c, update.r, update.m, promises, currentUpdateApplyHandlers, updatedModules);
                    return promises;
                }, [])).then(function() {
                    return waitForBlockingPromises(function() {
                        if (applyOnUpdate) {
                            return internalApply(applyOnUpdate);
                        }
                        return setStatus("ready").then(function() {
                            return updatedModules;
                        });
                    });
                });
            });
        });
    }
    function hotApply(options) {
        if (currentStatus !== "ready") {
            return Promise.resolve().then(function() {
                throw new Error("apply() is only allowed in ready status (state: " + currentStatus + ")");
            });
        }
        return internalApply(options);
    }
    function internalApply(options) {
        options = options || {};
        applyInvalidatedModules();
        var results = currentUpdateApplyHandlers.map(function(handler) {
            return handler(options);
        });
        currentUpdateApplyHandlers = undefined;
        var errors = results.map(function(r) {
            return r.error;
        }).filter(Boolean);
        if (errors.length > 0) {
            return setStatus("abort").then(function() {
                throw errors[0];
            });
        }
        // Now in "dispose" phase
        var disposePromise = setStatus("dispose");
        results.forEach(function(result) {
            if (result.dispose) result.dispose();
        });
        // Now in "apply" phase
        var applyPromise = setStatus("apply");
        var error;
        var reportError = function(err) {
            if (!error) error = err;
        };
        var outdatedModules = [];
        results.forEach(function(result) {
            if (result.apply) {
                var modules = result.apply(reportError);
                if (modules) {
                    for(var i = 0; i < modules.length; i++){
                        outdatedModules.push(modules[i]);
                    }
                }
            }
        });
        return Promise.all([
            disposePromise,
            applyPromise
        ]).then(function() {
            // handle errors in accept handlers and self accepted module load
            if (error) {
                return setStatus("fail").then(function() {
                    throw error;
                });
            }
            if (queuedInvalidatedModules) {
                return internalApply(options).then(function(list) {
                    outdatedModules.forEach(function(moduleId) {
                        if (list.indexOf(moduleId) < 0) list.push(moduleId);
                    });
                    return list;
                });
            }
            return setStatus("idle").then(function() {
                return outdatedModules;
            });
        });
    }
    function applyInvalidatedModules() {
        if (queuedInvalidatedModules) {
            if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
            Object.keys($hmrInvalidateModuleHandlers$).forEach(function(key) {
                queuedInvalidatedModules.forEach(function(moduleId) {
                    $hmrInvalidateModuleHandlers$[key](moduleId, currentUpdateApplyHandlers);
                });
            });
            queuedInvalidatedModules = undefined;
            return true;
        }
    }
};
}}),
"[project]/node_modules/next/dist/compiled/webpack/JavascriptHotModuleReplacement.runtime.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// @ts-nocheck
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ "use strict";
var $installedChunks$ = undefined;
var $loadUpdateChunk$ = undefined;
var $moduleCache$ = undefined;
var $moduleFactories$ = undefined;
var $ensureChunkHandlers$ = undefined;
var $hasOwnProperty$ = undefined;
var $hmrModuleData$ = undefined;
var $hmrDownloadUpdateHandlers$ = undefined;
var $hmrInvalidateModuleHandlers$ = undefined;
var __webpack_require__ = undefined;
module.exports = function() {
    var currentUpdateChunks;
    var currentUpdate;
    var currentUpdateRemovedChunks;
    var currentUpdateRuntime;
    function applyHandler(options) {
        if ($ensureChunkHandlers$) delete $ensureChunkHandlers$.$key$Hmr;
        currentUpdateChunks = undefined;
        function getAffectedModuleEffects(updateModuleId) {
            var outdatedModules = [
                updateModuleId
            ];
            var outdatedDependencies = {};
            var queue = outdatedModules.map(function(id) {
                return {
                    chain: [
                        id
                    ],
                    id: id
                };
            });
            while(queue.length > 0){
                var queueItem = queue.pop();
                var moduleId = queueItem.id;
                var chain = queueItem.chain;
                var module1 = $moduleCache$[moduleId];
                if (!module1 || module1.hot._selfAccepted && !module1.hot._selfInvalidated) continue;
                if (module1.hot._selfDeclined) {
                    return {
                        type: "self-declined",
                        chain: chain,
                        moduleId: moduleId
                    };
                }
                if (module1.hot._main) {
                    return {
                        type: "unaccepted",
                        chain: chain,
                        moduleId: moduleId
                    };
                }
                for(var i = 0; i < module1.parents.length; i++){
                    var parentId = module1.parents[i];
                    var parent = $moduleCache$[parentId];
                    if (!parent) continue;
                    if (parent.hot._declinedDependencies[moduleId]) {
                        return {
                            type: "declined",
                            chain: chain.concat([
                                parentId
                            ]),
                            moduleId: moduleId,
                            parentId: parentId
                        };
                    }
                    if (outdatedModules.indexOf(parentId) !== -1) continue;
                    if (parent.hot._acceptedDependencies[moduleId]) {
                        if (!outdatedDependencies[parentId]) outdatedDependencies[parentId] = [];
                        addAllToSet(outdatedDependencies[parentId], [
                            moduleId
                        ]);
                        continue;
                    }
                    delete outdatedDependencies[parentId];
                    outdatedModules.push(parentId);
                    queue.push({
                        chain: chain.concat([
                            parentId
                        ]),
                        id: parentId
                    });
                }
            }
            return {
                type: "accepted",
                moduleId: updateModuleId,
                outdatedModules: outdatedModules,
                outdatedDependencies: outdatedDependencies
            };
        }
        function addAllToSet(a, b) {
            for(var i = 0; i < b.length; i++){
                var item = b[i];
                if (a.indexOf(item) === -1) a.push(item);
            }
        }
        // at begin all updates modules are outdated
        // the "outdated" status can propagate to parents if they don't accept the children
        var outdatedDependencies = {};
        var outdatedModules = [];
        var appliedUpdate = {};
        var warnUnexpectedRequire = function warnUnexpectedRequire(module1) {
            console.warn("[HMR] unexpected require(" + module1.id + ") to disposed module");
        };
        for(var moduleId in currentUpdate){
            if ($hasOwnProperty$(currentUpdate, moduleId)) {
                var newModuleFactory = currentUpdate[moduleId];
                /** @type {TODO} */ var result = newModuleFactory ? getAffectedModuleEffects(moduleId) : {
                    type: "disposed",
                    moduleId: moduleId
                };
                /** @type {Error|false} */ var abortError = false;
                var doApply = false;
                var doDispose = false;
                var chainInfo = "";
                if (result.chain) {
                    chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
                }
                switch(result.type){
                    case "self-declined":
                        if (options.onDeclined) options.onDeclined(result);
                        if (!options.ignoreDeclined) abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
                        break;
                    case "declined":
                        if (options.onDeclined) options.onDeclined(result);
                        if (!options.ignoreDeclined) abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
                        break;
                    case "unaccepted":
                        if (options.onUnaccepted) options.onUnaccepted(result);
                        if (!options.ignoreUnaccepted) abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
                        break;
                    case "accepted":
                        if (options.onAccepted) options.onAccepted(result);
                        doApply = true;
                        break;
                    case "disposed":
                        if (options.onDisposed) options.onDisposed(result);
                        doDispose = true;
                        break;
                    default:
                        throw new Error("Unexception type " + result.type);
                }
                if (abortError) {
                    return {
                        error: abortError
                    };
                }
                if (doApply) {
                    appliedUpdate[moduleId] = newModuleFactory;
                    addAllToSet(outdatedModules, result.outdatedModules);
                    for(moduleId in result.outdatedDependencies){
                        if ($hasOwnProperty$(result.outdatedDependencies, moduleId)) {
                            if (!outdatedDependencies[moduleId]) outdatedDependencies[moduleId] = [];
                            addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
                        }
                    }
                }
                if (doDispose) {
                    addAllToSet(outdatedModules, [
                        result.moduleId
                    ]);
                    appliedUpdate[moduleId] = warnUnexpectedRequire;
                }
            }
        }
        currentUpdate = undefined;
        // Store self accepted outdated modules to require them later by the module system
        var outdatedSelfAcceptedModules = [];
        for(var j = 0; j < outdatedModules.length; j++){
            var outdatedModuleId = outdatedModules[j];
            var module1 = $moduleCache$[outdatedModuleId];
            if (module1 && (module1.hot._selfAccepted || module1.hot._main) && // removed self-accepted modules should not be required
            appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire && // when called invalidate self-accepting is not possible
            !module1.hot._selfInvalidated) {
                outdatedSelfAcceptedModules.push({
                    module: outdatedModuleId,
                    require: module1.hot._requireSelf,
                    errorHandler: module1.hot._selfAccepted
                });
            }
        }
        var moduleOutdatedDependencies;
        return {
            dispose: function() {
                currentUpdateRemovedChunks.forEach(function(chunkId) {
                    delete $installedChunks$[chunkId];
                });
                currentUpdateRemovedChunks = undefined;
                var idx;
                var queue = outdatedModules.slice();
                while(queue.length > 0){
                    var moduleId = queue.pop();
                    var module1 = $moduleCache$[moduleId];
                    if (!module1) continue;
                    var data = {};
                    // Call dispose handlers
                    var disposeHandlers = module1.hot._disposeHandlers;
                    for(j = 0; j < disposeHandlers.length; j++){
                        disposeHandlers[j].call(null, data);
                    }
                    $hmrModuleData$[moduleId] = data;
                    // disable module (this disables requires from this module)
                    module1.hot.active = false;
                    // remove module from cache
                    delete $moduleCache$[moduleId];
                    // when disposing there is no need to call dispose handler
                    delete outdatedDependencies[moduleId];
                    // remove "parents" references from all children
                    for(j = 0; j < module1.children.length; j++){
                        var child = $moduleCache$[module1.children[j]];
                        if (!child) continue;
                        idx = child.parents.indexOf(moduleId);
                        if (idx >= 0) {
                            child.parents.splice(idx, 1);
                        }
                    }
                }
                // remove outdated dependency from module children
                var dependency;
                for(var outdatedModuleId in outdatedDependencies){
                    if ($hasOwnProperty$(outdatedDependencies, outdatedModuleId)) {
                        module1 = $moduleCache$[outdatedModuleId];
                        if (module1) {
                            moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId];
                            for(j = 0; j < moduleOutdatedDependencies.length; j++){
                                dependency = moduleOutdatedDependencies[j];
                                idx = module1.children.indexOf(dependency);
                                if (idx >= 0) module1.children.splice(idx, 1);
                            }
                        }
                    }
                }
            },
            apply: function(reportError) {
                // insert new code
                for(var updateModuleId in appliedUpdate){
                    if ($hasOwnProperty$(appliedUpdate, updateModuleId)) {
                        $moduleFactories$[updateModuleId] = appliedUpdate[updateModuleId];
                    }
                }
                // run new runtime modules
                for(var i = 0; i < currentUpdateRuntime.length; i++){
                    currentUpdateRuntime[i](__webpack_require__);
                }
                // call accept handlers
                for(var outdatedModuleId in outdatedDependencies){
                    if ($hasOwnProperty$(outdatedDependencies, outdatedModuleId)) {
                        var module1 = $moduleCache$[outdatedModuleId];
                        if (module1) {
                            moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId];
                            var callbacks = [];
                            var errorHandlers = [];
                            var dependenciesForCallbacks = [];
                            for(var j = 0; j < moduleOutdatedDependencies.length; j++){
                                var dependency = moduleOutdatedDependencies[j];
                                var acceptCallback = module1.hot._acceptedDependencies[dependency];
                                var errorHandler = module1.hot._acceptedErrorHandlers[dependency];
                                if (acceptCallback) {
                                    if (callbacks.indexOf(acceptCallback) !== -1) continue;
                                    callbacks.push(acceptCallback);
                                    errorHandlers.push(errorHandler);
                                    dependenciesForCallbacks.push(dependency);
                                }
                            }
                            for(var k = 0; k < callbacks.length; k++){
                                try {
                                    callbacks[k].call(null, moduleOutdatedDependencies);
                                } catch (err) {
                                    if (typeof errorHandlers[k] === "function") {
                                        try {
                                            errorHandlers[k](err, {
                                                moduleId: outdatedModuleId,
                                                dependencyId: dependenciesForCallbacks[k]
                                            });
                                        } catch (err2) {
                                            if (options.onErrored) {
                                                options.onErrored({
                                                    type: "accept-error-handler-errored",
                                                    moduleId: outdatedModuleId,
                                                    dependencyId: dependenciesForCallbacks[k],
                                                    error: err2,
                                                    originalError: err
                                                });
                                            }
                                            if (!options.ignoreErrored) {
                                                reportError(err2);
                                                reportError(err);
                                            }
                                        }
                                    } else {
                                        if (options.onErrored) {
                                            options.onErrored({
                                                type: "accept-errored",
                                                moduleId: outdatedModuleId,
                                                dependencyId: dependenciesForCallbacks[k],
                                                error: err
                                            });
                                        }
                                        if (!options.ignoreErrored) {
                                            reportError(err);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                // Load self accepted modules
                for(var o = 0; o < outdatedSelfAcceptedModules.length; o++){
                    var item = outdatedSelfAcceptedModules[o];
                    var moduleId = item.module;
                    try {
                        item.require(moduleId);
                    } catch (err) {
                        if (typeof item.errorHandler === "function") {
                            try {
                                item.errorHandler(err, {
                                    moduleId: moduleId,
                                    module: $moduleCache$[moduleId]
                                });
                            } catch (err1) {
                                if (options.onErrored) {
                                    options.onErrored({
                                        type: "self-accept-error-handler-errored",
                                        moduleId: moduleId,
                                        error: err1,
                                        originalError: err
                                    });
                                }
                                if (!options.ignoreErrored) {
                                    reportError(err1);
                                    reportError(err);
                                }
                            }
                        } else {
                            if (options.onErrored) {
                                options.onErrored({
                                    type: "self-accept-errored",
                                    moduleId: moduleId,
                                    error: err
                                });
                            }
                            if (!options.ignoreErrored) {
                                reportError(err);
                            }
                        }
                    }
                }
                return outdatedModules;
            }
        };
    }
    $hmrInvalidateModuleHandlers$.$key$ = function(moduleId, applyHandlers) {
        if (!currentUpdate) {
            currentUpdate = {};
            currentUpdateRuntime = [];
            currentUpdateRemovedChunks = [];
            applyHandlers.push(applyHandler);
        }
        if (!$hasOwnProperty$(currentUpdate, moduleId)) {
            currentUpdate[moduleId] = $moduleFactories$[moduleId];
        }
    };
    $hmrDownloadUpdateHandlers$.$key$ = function(chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) {
        applyHandlers.push(applyHandler);
        currentUpdateChunks = {};
        currentUpdateRemovedChunks = removedChunks;
        currentUpdate = removedModules.reduce(function(obj, key) {
            obj[key] = false;
            return obj;
        }, {});
        currentUpdateRuntime = [];
        chunkIds.forEach(function(chunkId) {
            if ($hasOwnProperty$($installedChunks$, chunkId) && $installedChunks$[chunkId] !== undefined) {
                promises.push($loadUpdateChunk$(chunkId, updatedModulesList));
                currentUpdateChunks[chunkId] = true;
            } else {
                currentUpdateChunks[chunkId] = false;
            }
        });
        if ($ensureChunkHandlers$) {
            $ensureChunkHandlers$.$key$Hmr = function(chunkId, promises) {
                if (currentUpdateChunks && $hasOwnProperty$(currentUpdateChunks, chunkId) && !currentUpdateChunks[chunkId]) {
                    promises.push($loadUpdateChunk$(chunkId));
                    currentUpdateChunks[chunkId] = true;
                }
            };
        }
    };
};
}}),
"[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
exports.__esModule = true;
exports.default = undefined;
exports.init = function() {
    if (process.env.NEXT_PRIVATE_LOCAL_WEBPACK) {
        Object.assign(exports, {
            // eslint-disable-next-line import/no-extraneous-dependencies
            BasicEvaluatedExpression: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/javascript/BasicEvaluatedExpression'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            ConcatenatedModule: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/optimize/ConcatenatedModule'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            makePathsAbsolute: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/util/identifier'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })().makePathsAbsolute,
            // eslint-disable-next-line import/no-extraneous-dependencies
            ModuleFilenameHelpers: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/ModuleFilenameHelpers'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            NodeTargetPlugin: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/node/NodeTargetPlugin'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            RuntimeGlobals: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/RuntimeGlobals'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            SourceMapDevToolModuleOptionsPlugin: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/SourceMapDevToolModuleOptionsPlugin'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            StringXor: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/util/StringXor'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            NormalModule: (()=>{
                const e = new Error("Cannot find module 'webpack/lib/NormalModule'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            // eslint-disable-next-line import/no-extraneous-dependencies
            sources: (()=>{
                const e = new Error("Cannot find module 'webpack'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })().sources,
            // eslint-disable-next-line import/no-extraneous-dependencies
            webpack: (()=>{
                const e = new Error("Cannot find module 'webpack'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })()
        });
    } else {
        Object.assign(exports, __turbopack_require__("[project]/node_modules/next/dist/compiled/webpack/bundle5.js [app-rsc] (ecmascript)")());
    }
};
}}),
"[project]/node_modules/next/dist/compiled/webpack/webpack-lib.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/webpack/webpack.js [app-rsc] (ecmascript)").webpack;
}}),

};

//# sourceMappingURL=node_modules_next_dist_compiled_webpack_564be6._.js.map